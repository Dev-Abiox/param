name: Production CI/CD Pipeline with Blue-Green Deployment

on:
  push:
    branches: [main, master]
  pull_request:
    branches: [main, master]

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  test-backend:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        python-version: [3.10]
        
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Set up Python ${{ matrix.python-version }}
      uses: actions/setup-python@v5
      with:
        python-version: ${{ matrix.python-version }}
        
    - name: Install dependencies
      run: |
        cd backend_v3
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        
    - name: Run backend tests
      run: |
        cd backend_v3
        python -m pytest --cov=apps --cov-report=xml --cov-report=term
        
    - name: Upload coverage to Codecov
      uses: codecov/codecov-action@v3
      with:
        file: ./backend_v3/coverage.xml
        flags: backend
        name: backend

  test-frontend:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        
    - name: Install frontend dependencies
      run: |
        cd frontend
        npm ci --legacy-peer-deps
        
    - name: Run frontend tests
      run: |
        cd frontend
        npm test -- --passWithNoTests --ci --coverage --coverageReporters=lcov
        
    - name: Upload coverage to Codecov
      uses: codecov/codecov-action@v3
      with:
        file: ./frontend/coverage/lcov.info
        flags: frontend
        name: frontend

  build-and-push:
    needs: [test-backend, test-frontend]
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master'
    
    permissions:
      contents: read
      packages: write
      
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Log in to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}
        
    - name: Extract metadata for Docker
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
        
    - name: Build and push Docker images
      uses: docker/build-push-action@v5
      with:
        context: .
        file: ./backend_v3/Dockerfile
        push: true
        tags: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest,${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}
        labels: ${{ steps.meta.outputs.labels }}
        
    - name: Build and push frontend image
      uses: docker/build-push-action@v5
      with:
        context: .
        file: ./frontend/Dockerfile
        push: true
        tags: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-frontend:latest,${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-frontend:${{ github.sha }}
        labels: ${{ steps.meta.outputs.labels }}

  deploy-blue-green:
    needs: build-and-push
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Setup SSH key for deployment
      uses: webfactory/ssh-agent@v0.8.0
      with:
        ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}
        
    - name: Configure known hosts
      run: |
        mkdir -p ~/.ssh
        ssh-keyscan -H ${{ secrets.HOST_IP }} >> ~/.ssh/known_hosts
        
    - name: Deploy to BigRock KVM (Blue-Green)
      run: |
        # SSH into the server and execute blue-green deployment script
        ssh root@${{ secrets.HOST_IP }} << 'EOF'
          set -e
          
          # Define deployment directory
          DEPLOY_DIR="/opt/clinomic-b12-platform"
          CURRENT_BLUE="$DEPLOY_DIR/blue"
          CURRENT_GREEN="$DEPLOY_DIR/green"
          NEW_VERSION=$(date +%Y%m%d_%H%M%S)
          
          # Determine current and next environments
          if [ -f "$DEPLOY_DIR/current_env" ]; then
              CURRENT_ENV=$(cat $DEPLOY_DIR/current_env)
          else
              CURRENT_ENV="blue"
          fi
          
          if [ "$CURRENT_ENV" = "blue" ]; then
              NEXT_ENV="green"
              NEXT_DIR="$CURRENT_GREEN"
          else
              NEXT_ENV="blue"
              NEXT_DIR="$CURRENT_BLUE"
          fi
          
          echo "Current environment: $CURRENT_ENV"
          echo "Deploying to: $NEXT_ENV"
          
          # Pull latest images
          docker pull ghcr.io/${{ github.repository }}:latest
          docker pull ghcr.io/${{ github.repository }}-frontend:latest
          
          # Create new deployment directory if it doesn't exist
          mkdir -p $NEXT_DIR
          
          # Copy updated docker-compose file and environment files
          cp -f $DEPLOY_DIR/docker-compose.prod.yml $NEXT_DIR/
          cp -f $DEPLOY_DIR/.env $NEXT_DIR/ 2>/dev/null || echo ".env file not found"
          
          # Generate new secrets if they don't exist
          if [ ! -f "$NEXT_DIR/secrets/postgres_password" ]; then
              mkdir -p $NEXT_DIR/secrets
              openssl rand -hex 32 > $NEXT_DIR/secrets/postgres_password
              openssl rand -hex 32 > $NEXT_DIR/secrets/django_secret_key
              openssl rand -base64 32 > $NEXT_DIR/secrets/fernet_key
          fi
          
          # Stop any existing containers in the next environment
          cd $NEXT_DIR
          docker compose down 2>/dev/null || true
          
          # Update image tags in docker-compose file
          sed -i "s|image: ghcr.io/${{ github.repository }}:.*|image: ghcr.io/${{ github.repository }}:latest|" docker-compose.prod.yml
          sed -i "s|image: ghcr.io/${{ github.repository }}-frontend:.*|image: ghcr.io/${{ github.repository }}-frontend:latest|" docker-compose.prod.yml
          
          # Start new environment
          docker compose up -d
          
          # Wait for services to become healthy
          echo "Waiting for services to become healthy..."
          sleep 30
          
          # Check health of the new deployment
          HEALTHY=true
          for service in backend frontend; do
              if ! docker compose ps | grep $service | grep -q "healthy"; then
                  echo "Service $service is not healthy"
                  HEALTHY=false
              fi
          done
          
          # If health check fails, rollback
          if [ "$HEALTHY" = "false" ]; then
              echo "Health check failed, rolling back..."
              docker compose down
              
              # Bring back the old environment
              cd $(dirname $NEXT_DIR)
              PREV_DIR=""
              if [ "$NEXT_ENV" = "green" ]; then
                  PREV_DIR="$CURRENT_BLUE"
              else
                  PREV_DIR="$CURRENT_GREEN"
              fi
              
              cd $PREV_DIR
              docker compose up -d
              echo "Rollback completed"
              exit 1
          fi
          
          # Health check with actual endpoint verification
          BACKEND_URL="http://localhost:8000/api/health/"
          FRONTEND_URL="http://localhost:3000/"
          
          echo "Checking backend health: $BACKEND_URL"
          for i in {1..10}; do
              if curl -f -s $BACKEND_URL > /dev/null; then
                  echo "Backend is healthy"
                  break
              fi
              echo "Waiting for backend... ($i/10)"
              sleep 10
          done
          
          echo "Checking frontend health: $FRONTEND_URL"
          for i in {1..10}; do
              if curl -f -s $FRONTEND_URL > /dev/null; then
                  echo "Frontend is healthy"
                  break
              fi
              echo "Waiting for frontend... ($i/10)"
              sleep 10
          done
          
          # Update the current environment pointer
          echo $NEXT_ENV > $DEPLOY_DIR/current_env
          
          # Clean up old environment
          if [ "$NEXT_ENV" = "green" ]; then
              OLD_DIR="$CURRENT_BLUE"
          else
              OLD_DIR="$CURRENT_GREEN"
          fi
          
          cd $OLD_DIR
          docker compose down
          
          echo "Blue-green deployment completed successfully!"
          echo "Active environment: $NEXT_ENV"
        EOF
        
    - name: Slack Notification Success
      if: success()
      uses: 8398a7/action-slack@v3
      with:
        status: success
        text: ':white_check_mark: Production deployment successful!'
      env:
        SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
        
    - name: Slack Notification Failure
      if: failure()
      uses: 8398a7/action-slack@v3
      with:
        status: failure
        text: ':x: Production deployment failed!'
      env:
        SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}