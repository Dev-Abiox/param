name: Testing Environment Deployment

on:
  push:
    branches: [ develop, staging, feature/** ]
  workflow_dispatch:
    inputs:
      branch:
        description: 'Branch to deploy'
        required: true
        default: 'develop'

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  build-test-image:
    runs-on: ubuntu-latest
    
    permissions:
      contents: read
      packages: write
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
    
    - name: Log in to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Extract metadata for backend
      id: meta-backend
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-backend
        tags: |
          type=ref,event=branch
          type=sha,prefix=test-
          type=raw,value=test-${{ github.sha }}
    
    - name: Extract metadata for frontend
      id: meta-frontend
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-frontend
        tags: |
          type=ref,event=branch
          type=sha,prefix=test-
          type=raw,value=test-${{ github.sha }}
    
    - name: Build and push backend
      uses: docker/build-push-action@v5
      with:
        context: ./backend_v3
        push: true
        tags: ${{ steps.meta-backend.outputs.tags }}
        labels: ${{ steps.meta-backend.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max
    
    - name: Build and push frontend
      uses: docker/build-push-action@v5
      with:
        context: ./frontend
        push: true
        tags: ${{ steps.meta-frontend.outputs.tags }}
        labels: ${{ steps.meta-frontend.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max

  deploy-to-testing:
    needs: build-test-image
    runs-on: ubuntu-latest
    
    environment: testing
    
    steps:
    - name: Deploy to testing environment
      uses: appleboy/ssh-action@v1.0.0
      with:
        host: ${{ secrets.TESTING_VM_HOST }}
        username: ${{ secrets.VM_USERNAME }}
        key: ${{ secrets.VPS_SSH_PRIVATE_KEY }}
        script: |
          cd /opt/clinomic-testing
          
          # Create directory if it doesn't exist
          if [ ! -d "/opt/clinomic-testing" ]; then
            sudo mkdir -p /opt/clinomic-testing
            sudo chown $USER:$USER /opt/clinomic-testing
            cd /opt/clinomic-testing
          fi
          
          # Pull latest test images
          docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-backend:test-${{ github.sha }}
          docker pull ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-frontend:test-${{ github.sha }}
          
          # Create/update docker-compose.testing.yml
          cat > docker-compose.testing.yml << 'EOF'
          version: '3.8'
          
          services:
            db:
              image: postgres:15-alpine
              restart: always
              environment:
                POSTGRES_DB: clinomic_testing
                POSTGRES_USER: postgres
                POSTGRES_PASSWORD: $${POSTGRES_PASSWORD}
              volumes:
                - postgres_testing_data:/var/lib/postgresql/data
              ports:
                - "5434:5432"
              healthcheck:
                test: ["CMD-SHELL", "pg_isready -U postgres"]
                interval: 10s
                timeout: 5s
                retries: 5
          
            backend_testing:
              image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-backend:test-${{ github.sha }}
              restart: always
              environment:
                - DEBUG=True
                - APP_ENV=testing
                - POSTGRES_HOST=db
                - POSTGRES_PORT=5432
                - POSTGRES_DB=clinomic_testing
                - POSTGRES_USER=postgres
                - POSTGRES_PASSWORD=$${POSTGRES_PASSWORD}
                - DJANGO_SECRET_KEY=$${DJANGO_SECRET_KEY}
                - JWT_SECRET_KEY=$${JWT_SECRET_KEY}
                - JWT_REFRESH_SECRET_KEY=$${JWT_REFRESH_SECRET_KEY}
                - MASTER_ENCRYPTION_KEY=$${MASTER_ENCRYPTION_KEY}
              ports:
                - "8001:8000"
              depends_on:
                db:
                  condition: service_healthy
              volumes:
                - ./ml/models:/app/ml/models:ro
              healthcheck:
                test: ["CMD", "curl", "-f", "http://localhost:8000/api/health/live"]
                interval: 30s
                timeout: 10s
                retries: 3
          
            frontend_testing:
              image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}-frontend:test-${{ github.sha }}
              restart: always
              environment:
                - REACT_APP_BACKEND_URL=http://$${TESTING_VM_HOST}:8001
              ports:
                - "3001:3000"
              depends_on:
                - backend_testing
          
            nginx_testing:
              image: nginx:alpine
              restart: always
              ports:
                - "8080:80"
              volumes:
                - ./nginx.testing.conf:/etc/nginx/nginx.conf:ro
              depends_on:
                - backend_testing
                - frontend_testing
          
          volumes:
            postgres_testing_data:
          EOF
          
          # Create/update nginx configuration
          cat > nginx.testing.conf << 'EOF'
          events {
              worker_connections 1024;
          }
          
          http {
              upstream backend {
                  server backend_testing:8000;
              }
              
              upstream frontend {
                  server frontend_testing:3000;
              }
          
              server {
                  listen 80;
                  
                  # API routes
                  location /api/ {
                      proxy_pass http://backend;
                      proxy_set_header Host $host;
                      proxy_set_header X-Real-IP $remote_addr;
                      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                      proxy_set_header X-Forwarded-Proto $scheme;
                  }
                  
                  # Admin panel
                  location /admin/ {
                      proxy_pass http://backend;
                      proxy_set_header Host $host;
                      proxy_set_header X-Real-IP $remote_addr;
                      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                      proxy_set_header X-Forwarded-Proto $scheme;
                  }
                  
                  # Static files
                  location /static/ {
                      proxy_pass http://backend;
                  }
                  
                  # Frontend app
                  location / {
                      proxy_pass http://frontend;
                      proxy_set_header Host $host;
                      proxy_set_header X-Real-IP $remote_addr;
                      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                      proxy_set_header X-Forwarded-Proto $scheme;
                  }
              }
          }
          EOF
          
          # Stop existing containers
          docker-compose -f docker-compose.testing.yml down || true
          
          # Start services
          docker-compose -f docker-compose.testing.yml up -d
          
          # Wait for health check
          timeout 120 bash -c 'until curl -sf http://${{ secrets.TESTING_VM_HOST }}:8001/api/health/live; do sleep 2; done' || {
            echo "Health check failed after 120 seconds"
            docker-compose -f docker-compose.testing.yml logs
            exit 1
          }
          
          echo "Testing environment deployment completed successfully!"
          echo "Access URL: http://${{ secrets.TESTING_VM_HOST }}:8080"